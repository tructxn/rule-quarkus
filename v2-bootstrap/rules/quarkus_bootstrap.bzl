"""
Quarkus Bootstrap Augmentation Rule (Approach 2)

This rule implements Quarkus augmentation using the QuarkusBootstrap API.
It takes compiled application classes and runs the full Quarkus augmentation
pipeline to generate CDI proxies, optimized bytecode, and more.
"""

load("@rules_java//java:defs.bzl", "JavaInfo")

def _quarkus_bootstrap_impl(ctx):
    """
    Implementation of quarkus_bootstrap rule.

    This rule:
    1. Collects all JAR files from dependencies
    2. Runs BootstrapAugmentor with QuarkusBootstrap API
    3. Outputs the augmented application directory
    """

    # Output directory for augmented application
    output_dir = ctx.actions.declare_directory(ctx.label.name + "-quarkus-app")

    # Collect application JARs (user code)
    application_jars = []
    for dep in ctx.attr.application:
        if JavaInfo in dep:
            for output in dep[JavaInfo].outputs.jars:
                application_jars.append(output.class_jar)

    # Collect runtime JARs (Quarkus extensions + regular deps)
    runtime_jars = []
    for dep in ctx.attr.runtime_deps:
        if JavaInfo in dep:
            # Get transitive runtime JARs
            for jar in dep[JavaInfo].transitive_runtime_jars.to_list():
                runtime_jars.append(jar)

    # Collect deployment JARs (Quarkus deployment modules)
    deployment_jars = []
    for dep in ctx.attr.deployment_deps:
        if JavaInfo in dep:
            for jar in dep[JavaInfo].transitive_runtime_jars.to_list():
                deployment_jars.append(jar)

    # Build command arguments
    args = ctx.actions.args()
    args.add("--output-dir", output_dir.path)
    args.add("--app-name", ctx.attr.application_name)

    if ctx.attr.main_class:
        args.add("--main-class", ctx.attr.main_class)

    # Add JAR lists
    args.add("--application-jars", ",".join([jar.path for jar in application_jars]))
    args.add("--runtime-jars", ",".join([jar.path for jar in runtime_jars]))
    args.add("--deployment-jars", ",".join([jar.path for jar in deployment_jars]))

    # All input files
    inputs = depset(
        direct = application_jars,
        transitive = [
            depset(runtime_jars),
            depset(deployment_jars),
        ],
    )

    # Run augmentor
    ctx.actions.run(
        outputs = [output_dir],
        inputs = inputs,
        executable = ctx.executable._augmentor,
        arguments = [args],
        mnemonic = "QuarkusBootstrap",
        progress_message = "Running Quarkus augmentation for %s" % ctx.label.name,
    )

    # Create output JAR reference for downstream targets
    # The main JAR is in output_dir/quarkus-run.jar
    return [
        DefaultInfo(
            files = depset([output_dir]),
            runfiles = ctx.runfiles(files = [output_dir]),
        ),
    ]

quarkus_bootstrap = rule(
    implementation = _quarkus_bootstrap_impl,
    attrs = {
        "application": attr.label_list(
            providers = [JavaInfo],
            mandatory = True,
            doc = "Application library targets (compiled user code)",
        ),
        "runtime_deps": attr.label_list(
            providers = [JavaInfo],
            default = [],
            doc = "Runtime dependencies (Quarkus extensions, other libs)",
        ),
        "deployment_deps": attr.label_list(
            providers = [JavaInfo],
            default = [],
            doc = "Deployment dependencies (Quarkus *-deployment modules)",
        ),
        "application_name": attr.string(
            mandatory = True,
            doc = "Application name",
        ),
        "main_class": attr.string(
            default = "io.quarkus.runner.GeneratedMain",
            doc = "Main class (usually auto-generated by Quarkus)",
        ),
        "_augmentor": attr.label(
            default = Label("//v2-bootstrap/tools:bootstrap_augmentor"),
            executable = True,
            cfg = "exec",
            doc = "Bootstrap augmentor tool",
        ),
    },
    doc = """
    Runs Quarkus augmentation using QuarkusBootstrap API.

    This rule takes compiled application code and runs the full Quarkus
    augmentation pipeline, including:
    - Jandex indexing
    - CDI bean discovery and proxy generation
    - REST endpoint registration
    - Configuration processing
    - Bytecode optimization

    Output is a directory containing the complete quarkus-app structure.

    Example:
        quarkus_bootstrap(
            name = "my-app-augmented",
            application = [":my-app-lib"],
            runtime_deps = [
                "@maven//:io_quarkus_quarkus_arc",
                "@maven//:io_quarkus_quarkus_resteasy_reactive",
            ],
            deployment_deps = [
                "@maven//:io_quarkus_quarkus_arc_deployment",
                "@maven//:io_quarkus_quarkus_resteasy_reactive_deployment",
            ],
            application_name = "my-app",
        )
    """,
)
