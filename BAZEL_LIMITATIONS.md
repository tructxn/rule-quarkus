# Bazel Limitations with Quarkus

## Current Challenge: Quarkus Bootstrap in Bazel

### The Problem

Quarkus has two runtime modes:

1. **Development Mode (IDE Launch)** - What `Quarkus.run()` tries to use
   - Expects Maven/Gradle project structure
   - Looks for `src/main/java`, `target/classes`, etc.
   - Performs on-the-fly compilation
   - Enables hot reload
   - **Does NOT work with Bazel** - throws `IllegalStateException: Failed to locate project dir`

2. **Production Mode (Augmented)** - What `quarkus-maven-plugin` creates
   - Requires build-time bytecode augmentation
   - Generates optimized runner classes
   - Creates fast-jar or uber-jar packaging
   - **Not yet implemented in Bazel rules**

### Why the Error Occurred

```
java.lang.IllegalStateException: Failed to locate project dir for
/private/var/tmp/_bazel_tructxn/.../bazel-out/.../libhello-world_lib.jar
```

When you call `Quarkus.run()`, it:
1. Tries to find the project root directory
2. Looks for Maven/Gradle build files
3. Expects to find source code at `src/main/java`
4. Tries to set up hot reload watching

None of these exist in Bazel's output structure, which looks like:
```
bazel-out/darwin_arm64-fastbuild/bin/examples/hello-world/
├── hello-world (executable)
├── hello-world.jar
└── libhello-world_lib.jar
```

### Current Workaround

We're using a **simplified runtime** that bypasses the full Quarkus bootstrap:

```java
public class QuarkusApp {
    public static void main(String... args) {
        // Directly use Vert.x (what Quarkus uses underneath)
        Vertx vertx = Vertx.vertx();
        HttpServer server = vertx.createHttpServer();

        // Manual routing instead of @Path annotation scanning
        server.requestHandler(request -> {
            if (request.path().equals("/hello")) {
                request.response().end("Hello from Quarkus with Bazel!");
            }
        });

        server.listen(8080);
    }
}
```

**Trade-offs:**
- ✅ Works with `bazel run`
- ✅ Uses same HTTP stack as Quarkus (Vert.x)
- ❌ No CDI (Arc) integration
- ❌ No automatic `@Path` endpoint scanning
- ❌ No hot reload
- ❌ Manual routing required

### Future Solution: Implement Build-Time Augmentation

To properly support Quarkus with Bazel, we need to:

#### 1. Add Augmentation Phase
```python
def quarkus_app(name, srcs, ...):
    # Compile sources
    java_library(name = name + "_unaugmented", ...)

    # Run Quarkus augmentation
    quarkus_augment(
        name = name + "_augmented",
        input = name + "_unaugmented",
        # Uses io.quarkus:quarkus-bootstrap-core to transform bytecode
    )

    # Create final binary
    java_binary(name = name, runtime_deps = [name + "_augmented"])
```

#### 2. Generate Application Metadata
Create `quarkus-application.dat` with:
- Discovered beans
- REST endpoints
- Configuration
- Resource paths

#### 3. Use Production Bootstrap
Instead of `Quarkus.run()`, use the generated main class:
```java
// Generated by augmentation
io.quarkus.runner.ApplicationImpl.main(args)
```

### Comparison with rules_spring

**rules_spring** works better because:
- Spring Boot doesn't require build-time augmentation
- Spring scans classpath at runtime (slower, but works)
- Spring Boot JARs are standard JARs with manifest

**Quarkus** is harder because:
- Requires compile-time bytecode transformation
- Optimized for fast startup (less runtime flexibility)
- Expects specific directory structure for dev mode

### What Works Now

✅ **Basic Java application structure**
✅ **Bazel build and packaging**
✅ **HTTP server using Vert.x**
✅ **Manual endpoint routing**
✅ **Resource loading (application.properties)**

### What Doesn't Work Yet

❌ **@Path annotation scanning**
❌ **@Inject CDI**
❌ **@ConfigProperty**
❌ **Quarkus.run() bootstrap**
❌ **Hot reload / dev mode**
❌ **Native image compilation**

### Recommended Path Forward

**Option 1: Simplified Runtime (Current)**
- Continue with Vert.x-based approach
- Provide helper utilities for routing
- Skip full Quarkus runtime
- Similar to how Micronaut works

**Option 2: Full Augmentation (Future)**
- Implement Quarkus augmentation as Bazel rule
- Generate production-mode artifacts
- Support all Quarkus features
- More complex, but full compatibility

**Option 3: Hybrid Approach**
- Use Quarkus for production builds
- Keep simplified runtime for development
- Best of both worlds

### Similar Projects

- **rules_spring** - Works because Spring doesn't need augmentation
- **rules_micronaut** - Would face similar challenges
- **rules_kotlin** - Analogous compiler plugin integration

### Resources

- [Quarkus Build Process](https://quarkus.io/guides/writing-extensions#build-time-principle)
- [Quarkus Bootstrap](https://github.com/quarkusio/quarkus/tree/main/independent-projects/bootstrap)
- [Bazel Rules Authoring](https://bazel.build/extending/rules)
